{
  "hash": "5b21d345295bcdff7312aade8bb8f527",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"DAL tutorial - Week 8\"\nsubtitle: \"Advanced plotting\"\neditor: visual\nformat: \n  html:\n    css: [webex.css]\n    include-after-body: [webex.js]\n---\n\n\n## Overview\n\nIn this tutorial, you can go through the different sections in any order you like and you can pick and choose which sections you want to work on.\n\nThe tutors will be able to help you chose sections that might be useful based on your interests or your dissertation projects (whether you are working on it now or you will next year!).\n\nIn this tutorial, there will be less explicit instructions or explanations. Before starting, make sure you attach the necessary packages (like tidyverse).\n\nYou can find information on the data in the [QM data](https://uoelel.github.io/qm-data/) website.\n\n\n\n\n\n## Formant data\n\nIn this section we will plot formant data from Italian.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# .rda are R data files and they can be read with `load()`\nload(\"data/coretta2018a/formants.rda\")\n```\n:::\n\n\nThe data contains F1 and F2 measurements at 3 points within each vowel. We want to plot the values at the mid-point of the vowel.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nformants |> \n  ggplot(aes(f12, f22, colour = vowel)) +\n  geom_point(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](tutorial-w08_files/figure-html/f1-f2-1.png){width=672}\n:::\n:::\n\n\nThis doesn't look right tho... Shouldn't /a/ be at the bottom, /i/ on the top-left and /u/ on the top-right?\n\nLet's fix this! First we need to use `f22` as the *x*-axis and `f12` as the *y*-axis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nformants |> \n  ggplot(aes(f22, f12, colour = vowel)) +\n  geom_point(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](tutorial-w08_files/figure-html/f2-f1-1.png){width=672}\n:::\n:::\n\n\nBut now the plot is upside-down!\n\nTo fix this we need to reverse both axes with `scale_*_reverse()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nformants |> \n  ggplot(aes(f22, f12, colour = vowel)) +\n  geom_point(alpha = 0.5) +\n  scale_x_reverse() + scale_y_reverse()\n```\n\n::: {.cell-output-display}\n![](tutorial-w08_files/figure-html/f1-f2-reverse-1.png){width=672}\n:::\n:::\n\n\nWe can do better! Let's split the data for each participant and let's plot ellipses for each vowel.\n\nWe can plot speakers separately with `facet_wrap()`: this works like `facet_grid()` but instead of specifying variables for rows and columns you just specify one variable and the data of each value in that variable will be plotted in a separate panel. This is useful when you have many different values, like speaker here. (if you want to learn how to make your plot taller, like the one below, check the Extra box below).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nformants |> \n  ggplot(aes(f22, f12, colour = vowel)) +\n  geom_point(alpha = 0.5) +\n  stat_ellipse() +\n  scale_x_reverse() + scale_y_reverse() +\n  facet_wrap(vars(speaker), ncol = 3)\n```\n\n::: {.cell-output-display}\n![](tutorial-w08_files/figure-html/f1-f2-reverse-wrap-1.png){width=672}\n:::\n:::\n\n\nIf you want to learn how to normalise the data across speaker so that you can recreate the following plot, check @sec-f0 .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nformants |> \n  group_by(speaker) |> \n  mutate(\n    f1_z = (f12 - mean(f12)) / sd(f12),\n    f2_z = (f22 - mean(f22)) / sd(f22)\n  ) |> \n  ggplot(aes(f2_z, f1_z, colour = vowel)) +\n  geom_point(alpha = 0.5) +\n  stat_ellipse() +\n  scale_x_reverse() + scale_y_reverse() +\n  labs(\n    title = \"Normalised F1/F2 plot of 5 Italian vowels\",\n    x = \"F2 (norm)\", y = \"F1 (norm)\"\n  )\n```\n\n::: {.cell-output-display}\n![](tutorial-w08_files/figure-html/norm-vow-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-important collapse=\"true\"}\n#### Extra: Setting the figure aspect ratio\n\nYou can set the aspect ratio of a figure in a Quarto document with the `fig-asp` Quarto option.\n\n``` r\n{r}\n#| label: tall-figure\n#| fig-asp: 1.5\n\n(your figure code)\n```\n:::\n\n## Reaction times\n\nYou have learnt how to use density plots, but an alternative way of plotting continuous data by categorical groups is to use strip charts and violin plots, alone or in combination!\n\nLet's plot reaction times from the `shallow` data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshallow <- read_csv(\"data/song2020/shallow.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 6500 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (8): Group, ID, List, Target, Critical_Filler, Word_Nonword, Relation_ty...\ndbl (3): ACC, RT, logRT\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\nYou can plot violin plots using `geom_violin()`. A violin is basically just a density plot, mirrored vertically. The wider parts of the violin indicate a greater density of data around the related *y*-axis values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshallow |> \n  # we filter to include only the critical trials\n  filter(Critical_Filler == \"Critical\") |> \n  ggplot(aes(Relation_type, RT)) +\n  geom_violin() +\n  facet_grid(cols = vars(Group))\n```\n\n::: {.cell-output-display}\n![](tutorial-w08_files/figure-html/violin-1.png){width=672}\n:::\n:::\n\n\nWe can overlay a strip chart, which is basically just the raw data, plotted as dots that are jittered horizontally.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshallow |> \n  # we filter to include only the critical trials\n  filter(Critical_Filler == \"Critical\") |> \n  ggplot(aes(Relation_type, RT)) +\n  geom_violin() +\n  # the width argument in geom_jitter() specifies how wide the jitter should be, as\n  # a value between 0 and 1.\n  # the lower the number, the narrower the jitter.\n  geom_jitter(width = 0.1, alpha = 0.25) +\n  facet_grid(cols = vars(Group))\n```\n\n::: {.cell-output-display}\n![](tutorial-w08_files/figure-html/violin-strip-1.png){width=672}\n:::\n:::\n\n\nCan you tell if there are differences in RTs between the different groups and relation types?\n\n## Fundamental frequency (f0) {#sec-f0}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# .rda are R data files and they can be read with `load()`\nload(\"data/coretta2018a/formants.rda\")\n```\n:::\n\n\nLet's plot f0 for different vowels. We can use a violin plot with a strip chart (see previous section!).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nformants |> \n  ggplot(aes(label, f0)) +\n  geom_violin() +\n  geom_jitter(width = 0.1, alpha = 0.1)\n```\n\n::: {.cell-output-display}\n![](tutorial-w08_files/figure-html/f0-1.png){width=672}\n:::\n:::\n\n\nYou might notice something weird going on... The violins are quite bumpy! This is because different people have different mean f0.\n\nWe want to **normalise** the data across speakers, so that individual differences in mean f0 are removed. This process is also called standardisation or *z*-scoring.\n\n*Z*-scores are a standardised unit that allows you to compare things that are on different scales. Our f0 values are on different scales because some speakers have higher mean f0, some have lower mean f0.\n\n*Z-*scores are calculated by removing the mean from each value and dividing it by the standard deviation. Since we are normalising *within* subject, we need to calculate the mean and standard deviation for each participant and apply those to each participant's data separately.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nformants <- formants |> \n  # group data by speaker so that normalisation is applied for each speaker\n  # separately\n  group_by(speaker) |> \n  # calculate z-scores\n  mutate(\n    f0_z = (f0 - mean(f0)) / sd(f0)\n  )\n\nhead(formants$f0_z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3.4126740 -0.9289615  1.1254401 -0.5180812 -1.0111376  0.2488954\n```\n\n\n:::\n:::\n\n\nNow we can recreate the plot above but using `f0_z`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nformants |> \n  ggplot(aes(label, f0_z)) +\n  geom_violin() +\n  geom_jitter(aes(colour = vowel), width = 0.1, alpha = 0.1)\n```\n\n::: {.cell-output-display}\n![](tutorial-w08_files/figure-html/f0-z-plot-1.png){width=672}\n:::\n:::\n\n\nWhy is `colour = vowel` in `geom_jitter(aes(...))`? Because we want to colour only the jittered points. If we put `colour = vowel` in the main `ggplot(aes(...))` , then the violin *borders* would also be coloured.\n\nIf you want to colour the areas of the violins instead, you can use the `fill` aesthetic. This will work both in the main `ggplot(aes(...))` or in `geom_violin(aes(...))` because the points of `geom_jitter()` can't be given a colour fill, but only a colour.\n\n## Rating (Likert) scales\n\nRating scales, like Likert scales, are very strange variables. They are categorical and ordinal.\n\nDespite being very common, the practice of treating Likert scales as numeric is quite inappropriate. For an explanation, check the first two pages of [Verissimo 2021](https://doi.org/10.1017/S1366728921000316).\n\nA very nice type of plot that is very useful for Likert scale data is a so-called **divergent stacked bar chart**.\n\nThe HH package has a few handy functions to make creating divergent stacked bar charts very straightforward. You will have to install this package (remember not to include the code for installation in your document; you need to install the package only once).\n\nWe will create a plot of language attitudes towards Esperanto and Emilian (Gallo-Italian). Let's read the data (it's an `.rds` file!). Participants were asked the following: \"when you hear somebody speaking Emilian/Esperanto, you would think they are...\" and they were presented with 9 adjectives, which they had to rate from strongly disagree (meaning they strongly disagreed that somebody speaking Emilian/Esperanto had that quality) to strongly agree (meaning they strongly agreed that the person had that quality). Esperanto speakers rated Esperanto while Emilian speakers rated Emilian.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nemilianto_attitude <- readRDS(\"data/hampton2023/emilianto_attitude.rds\")\n```\n:::\n\n\nTo be able to plot with the `likert()` function from the HH package, we first need to wrangle the data.\n\nBasically, we need a new tibble with counts of each value of the scale for each of the adjectives participants had to rate. Make sure you understand each line of the following code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nemilianto_lik <- emilianto_attitude %>%\n  \n  # let's select only the columns we need\n  select(language, educated:familiar) %>%\n  \n  # let's pivot the data so that we get a longer tibble, with the columns\n  # language, adjective and score\n  pivot_longer(educated:familiar, names_to = \"adjective\", values_to = \"score\") %>%\n  \n  # and we count the numbers of each adjective and score combo\n  count(language, adjective, score) %>%\n  \n  # then we pivot again so that now the data is wider, with the columns,\n  # language, adjective, and one column for each of the five scores\n  pivot_wider(names_from = \"score\", values_from = n) %>%\n  \n  # we rename the scores to the actualy label that the participants saw\n  rename(\"strong disagree\" = `1`, \"disagree\" = `2`, \"neither\" = `3`, \"agree\" = `4`, \"strong agree\" = `5`)\nemilianto_lik\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"language\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"adjective\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"strong disagree\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"disagree\"],\"name\":[4],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"neither\"],\"name\":[5],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"agree\"],\"name\":[6],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"strong agree\"],\"name\":[7],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"Emilian\",\"2\":\"diligent\",\"3\":\"10\",\"4\":\"23\",\"5\":\"294\",\"6\":\"63\",\"7\":\"44\"},{\"1\":\"Emilian\",\"2\":\"educated\",\"3\":\"8\",\"4\":\"56\",\"5\":\"243\",\"6\":\"83\",\"7\":\"44\"},{\"1\":\"Emilian\",\"2\":\"familiar\",\"3\":\"44\",\"4\":\"37\",\"5\":\"51\",\"6\":\"100\",\"7\":\"202\"},{\"1\":\"Emilian\",\"2\":\"friendly\",\"3\":\"42\",\"4\":\"32\",\"5\":\"63\",\"6\":\"109\",\"7\":\"188\"},{\"1\":\"Emilian\",\"2\":\"intelligent\",\"3\":\"5\",\"4\":\"23\",\"5\":\"266\",\"6\":\"76\",\"7\":\"64\"},{\"1\":\"Emilian\",\"2\":\"kind\",\"3\":\"24\",\"4\":\"40\",\"5\":\"190\",\"6\":\"89\",\"7\":\"91\"},{\"1\":\"Emilian\",\"2\":\"refined\",\"3\":\"38\",\"4\":\"114\",\"5\":\"198\",\"6\":\"48\",\"7\":\"36\"},{\"1\":\"Emilian\",\"2\":\"trustworthy\",\"3\":\"26\",\"4\":\"32\",\"5\":\"227\",\"6\":\"71\",\"7\":\"78\"},{\"1\":\"Esperanto\",\"2\":\"diligent\",\"3\":\"3\",\"4\":\"3\",\"5\":\"80\",\"6\":\"42\",\"7\":\"19\"},{\"1\":\"Esperanto\",\"2\":\"educated\",\"3\":\"3\",\"4\":\"2\",\"5\":\"41\",\"6\":\"53\",\"7\":\"48\"},{\"1\":\"Esperanto\",\"2\":\"familiar\",\"3\":\"4\",\"4\":\"7\",\"5\":\"78\",\"6\":\"41\",\"7\":\"17\"},{\"1\":\"Esperanto\",\"2\":\"friendly\",\"3\":\"2\",\"4\":\"5\",\"5\":\"28\",\"6\":\"64\",\"7\":\"48\"},{\"1\":\"Esperanto\",\"2\":\"intelligent\",\"3\":\"2\",\"4\":\"4\",\"5\":\"66\",\"6\":\"52\",\"7\":\"23\"},{\"1\":\"Esperanto\",\"2\":\"kind\",\"3\":\"3\",\"4\":\"5\",\"5\":\"38\",\"6\":\"59\",\"7\":\"42\"},{\"1\":\"Esperanto\",\"2\":\"refined\",\"3\":\"2\",\"4\":\"6\",\"5\":\"102\",\"6\":\"27\",\"7\":\"10\"},{\"1\":\"Esperanto\",\"2\":\"trustworthy\",\"3\":\"4\",\"4\":\"6\",\"5\":\"60\",\"6\":\"48\",\"7\":\"29\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nNow we can finally plot this using the `likert()` function. The function takes a formula that describes how to plot the data: here, we want a divergent stacked bar for each adjective and we want all the scores (`adjective ~ .`), but we also want to facet by language (`| language`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHH::likert(\n  # formula\n  adjective ~ . | language,\n  # data\n  emilianto_lik,\n  as.percent = TRUE,\n  # plot title\n  main = \"Language attitudes towards Emilian and Esperanto\"\n)\n```\n\n::: {.cell-output-display}\n![](tutorial-w08_files/figure-html/emilianto-lik-plot-1.png){width=672}\n:::\n:::\n\n\nWhat is that `HH::likert()`? That's the R way of calling a function from a package directly, without the need to attach the full package with `library(HH)`. This is useful, for example, for packages that override functions from other packages when attached or for packages that attach a lot of package dependencies.\n\nIn most cases you won't have to worry, but if you ever think that function overwriting is causing issues, you know you can use the `package::function()` syntax.\n\nWhat can you tell about the attitude towards Emilian and Esperanto from the plot?\n",
    "supporting": [
      "tutorial-w08_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}