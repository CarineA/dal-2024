{
  "hash": "6993f3dba1424026cb64640dff8c00d9",
  "result": {
    "markdown": "---\ntitle: \"DAL tutorial - Week 6\"\nsubtitle: \"Data transformation II\"\neditor: visual\nexecute:\n  eval: false\nformat: \n  html:\n    css: [webex.css]\n    include-after-body: [webex.js]\n---\n\n\n## Summary measures\n\nDuring the lecture, we have learnt two types of measures.\n\n::: callout-tip\n#### Summary measures\n\n**Measures of central tendency** (mean, median, mode) indicate the typical or central value of a sample.\n\n**Measures of dispersion** (min-max, range, standard deviation) indicate the dispersion of the sample values around the central tendency value.\n:::\n\nWhen you work with data, you always want to get summary measures for most of the variables in the data.\n\nData reports usually include summary measures. It is also important to understand which summary measure is appropriate for which type of variable.\n\nWe have covered this in the lecture, so we won't go over it again here. Instead, you will learn how to obtain summary measures using the `summarise()` function from the [dplyr](https://dplyr.tidyverse.org) tidyverse package.\n\n`summarise()` takes at least two arguments:\n\n-   The data frame to summarise.\n\n-   One or more summary functions.\n\nFor example, let's get the mean the reaction time column `RT`. Easy!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(shallow, RT_mean = mean(RT))\n```\n:::\n\n\nGreat! The mean reaction times of the entire sample is 867 ms.\n\nWhat if we want also the standard deviation? Easy!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(shallow, RT_mean = mean(RT), RT_sd = sd(RT))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# This is a comment. Let's add 6 + 3.\n6 + 3\n```\n:::\n\n\nNow we know that reaction times are on average 867 ms long and have a standard deviation of about 293 ms (rounded to the nearest integer).\n\nLet's go all the way and also get the minimum and maximum RT values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(\n  shallow,\n  RT_mean = mean(RT), RT_sd = sd(RT),\n  RT_min = min(RT), RT_max = max(RT)\n)\n```\n:::\n\n\nFab! When writing a data report, you could write something like this.\n\n> Reaction times are on average 867 ms long (SD = 293 ms), with values ranging from 0 to 1994 ms.\n\nWe will learn more about standard deviations from Week 4 on, but for now just think of this as a relative measure of how dispersed the data are around the mean: the higher the SD, the greater the dispersion around the mean, i.e. the greater the variability in the data.\n\nWhen required, you can use the `median()` function to calculate the median, instead of the `mean()`. Go ahead and calculate the median reaction times in the data. Is it similar to the mean?\n\n::: callout-note\n#### Quiz 5\n\n\n\n\n\n::: {.callout-tip collapse=\"true\"}\n#### Hint\n\nCheck the documentation of `?mean`.\n:::\n:::\n\nNote that R has a `mode()` function, but alas this is not the statistical mode. To get the mode of a categorical variable you can just count the occurrences of the values of that variable and the value that occurs the most is the mode!\n\nKeep reading to learn how to count occurrences.\n\n### Count occurrences\n\nWe can use the `count()` function from the [dplyr](https://dplyr.tidyverse.org) tidyverse package to count the number of occurrences for each value of a specific column. Let's count how many trials are correct, i.e. let's count occurrences in the `ACC` column.\n\nAccuracy has been coded with `0` for incorrect and `1` for correct. We will see how this is not an ideal, although very common way, of coding binary variables. For now let's keep it as is.\n\nThe function `count()` takes the name of tibble and the name of column you want to count values in.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount(shallow, ACC)\n```\n:::\n\n\nHow many *correct* responses are there in the `shallow` tibble?\n\nNote that you can add **multiple column names, separated by commas**, to get counts for the combinations of values of each column.\n\nTry to get counts of the combination of `ACC` and `Group` (`L1` vs `L2` participants). Replace `...` with the right code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount(shallow, ...)\n```\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n#### Hint\n\nIn `count()`, include the names of the two columns you want to get counts of, separated by commas.\n:::\n\nAre there differences in accuracy between the L1 and L2 group?\n\n### Grouping data\n\nSometimes you might want to get summary measures for one variable depending on different values of another variable.\n\nYou can use the `group_by()` function from the [dplyr](https://dplyr.tidyverse.org) tidyverse package, together with `summarise()` to achieve that. Let's see how it works.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroup_by(shallow, Group) %>%\n  summarise(\n    RT_mean = mean(RT),\n    RT_sd = sd(RT)\n  )\n```\n:::\n\n\nThe `group_by()` function takes at least two arguments:\n\n-   The name of the tibble to group.\n\n-   The name of the columns to group the tibble by, separated by commas.\n\nHere we are grouping `shallow` by `Group`.\n\nIf you are baffled by that `%>%`, keep on reading.\n\n### What the pipe?!\n\nWait, what is that thing, `%>%`?\n\nIt's called a **pipe**. Think of a pipe as a teleporter.\n\nIn the code above we are chaining two functions together using the pipe opeartor `%>%`. The output of the first function (`group_by()`) is \"teleported\" into the second function `summarise()`.\n\nThe pipe `%>%` teleports the output of the preceding function as the first argument of the following function. The output of `group_by` is a (grouped) tibble, and `summarise()` needs a tibble as its first argument.\n\nThat's why the code above works!\n\nIn fact, you can even use a pipe for the tibble of `group_by()`, like so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshallow %>%\n  group_by(Group) %>%\n    summarise(\n      RT_mean = mean(RT),\n      RT_sd = sd(RT)\n    )\n```\n:::\n\n\nYou see that the output of the code is the same here as it is above.\n\nFor comparison, this is what the code would look like without the pipe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrouped_shallow <- group_by(shallow, Group)\n\nsummarise(\n  grouped_shallow,\n  RT_mean = mean(RT),\n  RT_sd = sd(RT)\n)\n```\n:::\n\n\nDon't worry too much if the concept of the pipe is not clear yet. It should become clearer later.\n\n::: callout-note\n#### Quiz 6\n\n\n\n\n\n::: {.callout-tip collapse=\"true\"}\n#### Hint\n\nFor 6b., check the documentation of `?summarise`.\n:::\n:::\n\n::: {.callout-note collapse=\"true\"}\n#### Practice 2\n\n-   Go to <https://github.com/stefanocoretta/infant-gestures> and download the `gestures.csv` file in the `data/` folder. This is data from the paper \\[A Cross-Cultural Analysis of Early Prelinguistic Gesture Development and Its Relationship to Language Development\\](https://doi.org/10.1111/cdev.13406).\n\n-   Read the file in R.\n\n-   Calculate the following:\n\n    -   Measure of central tendency and dispersion for the `count` column (it contains the number of gestures performed by each child in different tasks).\n\n    -   Measure of central tendency and dispersion for the `count`column grouped by `month` (the child's age).\n\n    -   Total number of gestures by children (`dyad`).\n\n    -   Number of children by `background`.\n\n-   Write a short paragraph where you report the measures. You can right this as comments in your R script. For examples, see above.\n\n::: {.callout-tip collapse=\"true\"}\n#### Hint\n\n-   To calculate the total number of gestures by children, you need the `sum()` function.\n\n-   To calculate the number of children by background, you need the `distinct()` function.\n:::\n\n::: {.callout-warning collapse=\"true\"}\n#### Solution\n\nHave you tried doing the exercise and couldn't work it out?\n\nThe you can check the code solution here...\n\n::: {.callout-important collapse=\"true\"}\n#### Code\n\n``` r\ngestures %>%\n  summarise(\n    count_med = median(count, na.rm = TRUE),\n    count_min = min(count, na.rm = TRUE),\n    count_max = max(count, na.rm = TRUE),\n    count_range = count_max - count_min\n  )\n\ngestures %>%\n  group_by(months) %>%\n  summarise(\n    count_med = median(count, na.rm = TRUE),\n    count_min = min(count, na.rm = TRUE),\n    count_max = max(count, na.rm = TRUE),\n    count_range = count_max - count_min\n  )\n\ngestures %>%\n  group_by(dyad) %>%\n  summarise(\n    count_tot = sum(count)\n  )\n\ngestures %>%\n  distinct(background, dyad) %>%\n  count(background)\n```\n:::\n:::\n:::\n\n## Summary\n\nThat's all for this week!\n\n::: {.callout-note appearance=\"minimal\"}\n**R Markdown**\n\n-   **R Markdown** can be used to create dynamic and reproducible reports.\n\n-   **Mark-up languages** are text-formatting systems that specify text formatting and structure using symbols or keywords. Markdown is the mark-up language R Markdown is based on.\n\n-   The main parts of an `.Rmd` file are the preamble, text and code chunks.\n\n**Plotting**\n\n-   **ggplot2** is a plotting package from the tidyverse.\n\n    -   To create a basic plot, you use the `ggplot()` function and specify `data` and `mapping`.\n\n    -   The `aes()` function allows you to specify aesthetics (like axes, colours, ...) in the `mapping` argument.\n\n    -   Geometries map data values onto shapes in the plot. All geometry functions are of the type `geom_*()`.\n\n-   **Scatter plots** are created with `geom_point()` and can be used with two numeric variables.\n\n-   **Bar charts** are created with `geom_bar()` and can be used to show the counts of different levels of a categorical variable.\n\n-   **Stacked bar charts** are created by specifying the `fill` aesthetic and can be used to show counts grouped by a second categorical variable.\n\n-   **Stacked bar charts showing proportions** can be created with the argument `position = \"fill\"` in `geom_bar()`.\n\n-   **Faceting** allows you to split the plot in different panels, based on other variables in the data. Faceting is achieved with `facet_grid()`.\n:::\n\nNext week, we will start learning about statistical modelling and while doing that you will also learn how to create density and violin plots and how to customise legends, titles and labels!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}